---
title: "session 3 notes"
author: "Tim Riffe"
date: "2025-07-09"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# usage of new lifetable function, `lt_full()`

To load, you can source straight from github like so:
```{r}
library(tidyverse)
library(janitor)
source("https://raw.githubusercontent.com/timriffe/BSSD2025Module2/refs/heads/master/02_lifetables.R")
```

To use, you need to group your data
```{r}
D <- read_csv("https://github.com/timriffe/BSSD2025Module2/raw/refs/heads/master/data/ES_mort.csv.gz",show_col_types = FALSE) |> 
  clean_names()

D |> 
  mutate(mx = if_else(is.na(mx) | mx == 0, .5, mx)) |> 
  filter(sex != "total") |> 
  group_by(year, sex) |> 
  group_modify(~lt_full(data= .x, groups = .y))
```


# calculate all WPP lifetables:

load it:
```{r}
wpp <- 
  read_csv("https://github.com/timriffe/BSSD2025Module2/raw/refs/heads/master/data/mxwpp.csv.gz", show_col_types = FALSE)
```

Now calculate lifetable for each subset (year, sex, location)

```{r, eval = FALSE}
wpp_lt <-
  wpp |> 
  mutate(sex = if_else(sex == "m","male","female")) |> 
  group_by(un_code, year, sex) |> 
  reframe(lt_full2(age = age, 
                   mx = mx, 
                   sex = sex,
                   radix = 1e5))
```

# 

In a move of pure desperation, I copied the function guts of `lt_full()` into a pure `mutate()`. Let's not rule out that I have an old machine as being the primary cause of this awkward delay.

```{r}
wpp_lt <-
  wpp |> 
  mutate(sex = if_else(sex == "m","male","female")) |> 
  group_by(un_code, year, sex) |> 
  mutate(
      # new use nx
      nx = c(diff(age),1),
      ax = mx_to_ax(mx = mx, 
                    sex = sex[1], 
                    age = age,
                    nx = nx),
      qx = calc_qx(mx = mx, 
                   ax = ax, 
                   age = age,
                   nx = nx),
      lx = calc_lx(qx = qx, radix = 1e5),
      dx = lx * qx,
      Lx = calc_Lx(lx = lx,
                   ax = ax,
                   dx = dx,
                   nx = nx),
      Tx = calc_Tx(Lx),
      ex = Tx / lx) |> 
  ungroup()
```


#

```{r}
#install.packages("countrycode")
library(countrycode)
wpp_iso <-
  wpp_lt |> 
  mutate(iso = countrycode(sourcevar = un_code, 
            origin = "un", 
            destination = "iso3c")) |> 
  filter(!is.na(iso)) 

```
```{r}
wpp_iso |> 
  filter(year < 2023,
         year %% 10 == 0) |> 
  ggplot(aes(x = age, y = mx, group = interaction(year,iso))) +
  geom_line(alpha = .05) +
  scale_y_log10() +
  facet_wrap(~sex)
```

# 

1. use `countrycode` package to add a column for `continent`
2. create a column called `decade`.
```{r}
year <- 1950:2020
decade <- year - year %% 10
```
3. use this helper function to estimate a slope of increase in life expectancy at birth, for each decade and continent. Tip: use `summarize()`
```{r}
slope_helper <- function(year, e0){
  coefs <- lm(e0~year) |> coef()
  coefs["year"]
}
```
4. display result as a table with decades in columns and continents in rows

```{r}
wpp_iso |> 
  mutate(continent = countrycode(iso, 
                                 origin = "iso3c", 
                                 destination = "continent"),
         decade = year - year %% 10) |> 
  filter(age == 0, year < 2020) |> 
  group_by(decade, continent) |> 
  summarize(pace = slope_helper(year = year, e0 = ex),
            .groups = "drop") |> 
  mutate(pace = round(pace,2)) |> 
  pivot_wider(names_from = decade, values_from = pace)
```

```{r}
wpp_iso |> 
  filter(age == 0,
         year < 2020,
         sex == "female") |> 
  mutate(continent = countrycode(iso, 
                                 origin = "iso3c", 
                                 destination = "continent")) |> 
  ggplot(aes(x = year, y = ex, group = iso, color= continent)) +
  geom_line(alpha = .3)
```

# let's standardize

Recall the formula for a weighted mean:

$$ \bar{x} = \frac{\sum x_i \cdot w_i}{\sum w_i} $$

```{r}
standards <- read_csv("https://raw.githubusercontent.com/timriffe/BSSD2025Module2/refs/heads/master/data/standards_abridged.csv", show_col_types = FALSE)

standards |> 
  group_by(standard) |> 
  mutate(n = c(diff(age),1)) |> 
  ungroup() |> 
  filter(grepl(standard, pattern = "World") | grepl(standard, pattern = "European")) |> 
  ggplot(aes(x = age, y = pop / n, color = standard)) +
  geom_step()
```

$$ \bar{x} = \frac{\sum x_i \cdot w_i}{\sum w_i} $$

First, pick out a standard, then discount the values from abridged ages to what they would be for single ages. Easiest to just assume a constant weight in each age group. It's OK since it's just used for weighting. In our case, just take care that the open age group extends as far as needed in the wpp data (up to 100+ rather than 90+)
```{r}
world_standard <-
  standards |> 
  filter(grepl(standard, pattern = "World")) |> 
  mutate(n = c(diff(age),11),
         w = pop / n) |> 
  rename(age_abr = age) |> 
  select(age_abr, w)
```

Now we need to figure out which abridged age each single age falls within. This three-step processing (`if_else()`) could be reframed as a `case_when()` call, but my mind isn't there right now, sry. Then we're ready to merge the standard to the wpp lifetables using the new `age_abr` column. The age-standardized death rates are then the weighted mean of age-specific death weights using the standard as the weights (`w`).
```{r}
wpp_iso |> 
  mutate(age_abr = age - age %% 5,
         age_abr = if_else(between(age,1,4),1,age_abr),
         age_abr = if_else(age >= 90, 90, age_abr)) |> 
  left_join(world_standard, by = join_by(age_abr)) |> 
  group_by(iso, sex, year) |> 
  summarize(sdr  = 1000 * sum(mx * w))
```

In practice age-standardization is most common in the literature in spatial epidemiology, where the values usually end up on choropleth maps (color maps). Although this does a good job of picking out high vs low, using the rate scale as the unit of reporting is still IMO coming too short vis what could be done.

# Decomposition

Pick out two subsets from the WPP
```{r}

```






















